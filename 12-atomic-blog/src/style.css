/*
1. analyze already written application
2. how to use context api and its benefits
3. the context api makes your components
  1. clean
  2. independent and stand alone because there is no prob. drilling the the consumer component doesn't depend on any thing to be passed to him from parent to come to live so you can really call it where ever you want in the entire app
4. how to use context api
  |  1. create context --> const PostContext = createContext();
  |  2. define the values in the provider that will be available for the child components
  |  3. consuming the context vlue -->   const { posts } = useContext(PostContext);

5. How to avoid wasted renders ( wasted renders: the renders that not affect the ui )
  |  1. component composition ( passing the child component as children so react creates it passes it to the component
  |  2. memomizing the components 
  |     @imp: memomizing component only affects props
  |     so for the memomized component when its parent re-render:
  |       1. has the same prop values -> no re-render
  |       2. has different prop values -> will re-render ofcourse ( because this will cause different view )
  |  3. memoizing values useing useMemo && memoizing functions using useCallback

note the unmemoized component will always re-render when its parent doesn't re-render

context + memoizing the value object so when the parent of the provider re-render this value will not re-created leading to the re-render of the consumers because of the context has changed
*/

* {
  padding: 0;
  margin: 0;
  box-sizing: border-box;
}

body {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
    Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;

  color: #222;
  line-height: 1.25;
  background: #fff;
  padding: 32px;
}

.fake-dark-mode {
  filter: invert(100%);
  transition: all 0.5s;
  -webkit-filter: invert(100%);
  -webkit-transition: all 0.5s;
  -moz-transition: all 0.5s;
  -ms-transition: all 0.5s;
  -o-transition: all 0.5s;
}

.btn-fake-dark-mode {
  position: fixed;
  top: 0;
  right: 0;
  padding: 16px;
  line-height: 1;
  font-size: 26px;
  background-color: #ffe8cc;
  border: none;
}

section {
  max-width: 1140px;
  margin: 0 auto;
}

header {
  margin-bottom: 32px;
  font-weight: bold;

  justify-content: space-between;
  display: flex;
}

h1 {
  font-size: 26px;
  display: flex;
  gap: 8px;
  align-items: center;
}

h1 span {
  font-size: 140%;
  line-height: 1;
}

h2 {
  text-transform: uppercase;
  margin-bottom: 24px;
  color: #333;
}

h3 {
  text-transform: capitalize;
  margin-bottom: 16px;
  color: #333;
}

header div {
  display: flex;
  gap: 32px;
  align-items: center;
}

header button {
  font-size: 14px;
}

form {
  padding: 24px;
  background-color: #fff4e6;
  display: flex;
  gap: 24px;
  margin-bottom: 40px;
}

main {
  margin-bottom: 40px;
}

aside {
  margin-bottom: 40px;
  opacity: 75%;
}

input,
textarea,
button {
  font-size: 16px;
  padding: 8px 12px;
  border: 1px solid #ffe8cc;
  font-family: inherit;
  color: inherit;
}

input {
  width: 12rem;
}

*::placeholder {
  color: #999;
}

*:focus {
  outline: 2px solid #ffa94d;
  border-radius: 2px;
}

textarea {
  flex: 1;
  height: 50px;
}

button {
  border: 1px solid #ffa94d;
  background-color: #ffa94d;
  font-weight: 700;
  padding: 9px 24px;
  cursor: pointer;
}

h3 {
  text-transform: capitalize;
  margin-bottom: 16px;
  color: #333;
}

main ul {
  list-style: none;
  display: grid;
  grid-template-columns: 1fr 1fr 1fr 1fr;
  gap: 32px;
}

main li {
  border: 1px solid #ffe8cc;
  padding: 16px 20px;
}

main li:hover {
  background-color: #fff4e6;
}

aside ul {
  font-size: 90%;
  list-style: none;
  display: flex;
  flex-direction: column;
  gap: 2px;
}

aside li {
  border: 1px solid #ffe8cc;
  padding: 4px 8px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

h2 + button {
  margin-bottom: 24px;
}

aside li button {
  padding: 4px 8px;
  font-size: 14px;
}
